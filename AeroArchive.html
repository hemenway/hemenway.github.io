<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>DFW Sectionals — Timeline</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    :root {
      --primary: #1e90ff;
      --bg-glass: rgba(20, 25, 30, 0.85);
      --text-light: #fff;
      --timeline-h: 6px;
    }

    html, body { height: 100%; margin: 0; background: #111; font-family: system-ui, -apple-system, sans-serif; overflow: hidden; }
    
    #map { height: 100%; width: 100%; z-index: 1; }

    /* --- UI Overlay --- */
    .ui-layer {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: min(1000px, 90vw);
      z-index: 1000;
      display: flex;
      flex-direction: column;
      gap: 10px;
      pointer-events: none; /* Let clicks pass through around controls */
    }

    /* --- Timeline Container --- */
    .controls-card {
      background: var(--bg-glass);
      backdrop-filter: blur(8px);
      padding: 16px 24px;
      border-radius: 16px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.5);
      display: flex;
      align-items: center;
      gap: 20px;
      pointer-events: auto;
      border: 1px solid rgba(255,255,255,0.1);
    }

    /* --- Play Button --- */
    .btn-play {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      background: var(--primary);
      border: none;
      color: white;
      font-size: 18px;
      cursor: pointer;
      display: grid;
      place-items: center;
      transition: transform 0.1s, background 0.2s;
      flex-shrink: 0;
    }
    .btn-play:hover { background: #4aa3ff; }
    .btn-play:active { transform: scale(0.95); }

    /* --- Timeline Bar --- */
    .timeline-track-wrapper {
      flex: 1;
      position: relative;
      height: 30px;
      display: flex;
      align-items: center;
      cursor: pointer;
    }

    .timeline-track {
      width: 100%;
      height: var(--timeline-h);
      background: rgba(255,255,255,0.2);
      border-radius: 4px;
      position: relative;
    }

    .timeline-progress {
      position: absolute;
      height: 100%;
      background: var(--primary);
      border-radius: 4px;
      width: 0%;
      pointer-events: none;
    }

    /* --- Ticks & Handles --- */
    .tick {
      position: absolute;
      width: 2px;
      height: 12px;
      background: rgba(255,255,255,0.5);
      top: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
    }

    .handle {
      position: absolute;
      width: 18px;
      height: 18px;
      background: #fff;
      border-radius: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 0 4px rgba(30,144,255,0.4);
      cursor: grab;
      transition: transform 0.1s;
    }
    .handle:active { cursor: grabbing; transform: translate(-50%, -50%) scale(1.2); }

    /* --- Text Info --- */
    .info-panel {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      min-width: 100px;
      color: var(--text-light);
    }
    .label-year { font-size: 24px; font-weight: 800; font-variant-numeric: tabular-nums; line-height: 1; }
    .label-sub { font-size: 11px; opacity: 0.7; margin-top: 4px; }

    /* --- Loading Spinner --- */
    .loader {
      width: 20px; height: 20px;
      border: 3px solid rgba(255,255,255,0.1);
      border-top-color: var(--primary);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      opacity: 0;
      transition: opacity 0.3s;
    }
    .loader.active { opacity: 1; }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* --- Toast --- */
    .toast {
      position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
      background: #c0392b; color: white; padding: 8px 16px;
      border-radius: 6px; font-size: 14px; z-index: 2000;
      opacity: 0; transition: opacity 0.3s; pointer-events: none;
    }
    .toast.visible { opacity: 1; }

  </style>
</head>
<body>

<div id="map"></div>
<div class="toast" id="toast"></div>

<div class="ui-layer">
  <div class="controls-card">
    <button class="btn-play" id="playBtn">▶</button>
    
    <div class="timeline-track-wrapper" id="trackWrapper">
      <div class="timeline-track">
        <div class="timeline-progress" id="progress"></div>
        <div id="ticksContainer"></div>
        <div class="handle" id="handle"></div>
      </div>
    </div>

    <div class="loader" id="loader" title="Loading tiles..."></div>

    <div class="info-panel">
      <div class="label-year" id="lblYear">Loading...</div>
      <div class="label-sub" id="lblRange"></div>
    </div>
  </div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
/**
 * CONFIGURATION
 */
const CONFIG = {
  rdntEndpoint: 'https://tiles.rdnt.io/tiles',
  rdntQuery: '&rgb=1,2,3',
  baseUrl: 'https://aeromap.io/',
  // Organized data structure
  frames: [
    { id: '2011', date: '2011-09-01', files: ['201109N_geo_COG.tif', '201109S_geo_COG.tif'] },
    { id: '2012', date: '2012-09-01', files: ['201209N_geo_COG.tif', '201209S_geo_COG.tif'] },
    { id: '2013', date: '2013-09-01', files: ['201309N_geo_COG.tif', '201309S_geo_COG.tif'] },
    { id: '2014', date: '2014-03-01', files: ['201403_geo_COG.tif'] },
    { id: '2015', date: '2015-03-01', files: ['201503_geo_COG.tif'] },
    { id: '2016 Mar', date: '2016-03-01', files: ['201603_geo_COG.tif'] },
    { id: '2016 Sep', date: '2016-09-01', files: ['201609_geo_COG.tif'] }
  ],
  animationSpeed: 1000, // ms per frame
  initialView: { center: [32.8, -97.0], zoom: 9 }
};

/**
 * UTILITIES
 */
const Utils = {
  buildCogUrl: (filename) => {
    const encoded = encodeURIComponent(CONFIG.baseUrl + filename);
    return `${CONFIG.rdntEndpoint}?url=${encoded}${CONFIG.rdntQuery}`;
  },
  toast: (msg, duration=3000) => {
    const el = document.getElementById('toast');
    el.textContent = msg;
    el.classList.add('visible');
    setTimeout(() => el.classList.remove('visible'), duration);
  }
};

/**
 * MAP CONTROLLER
 * Handles loading COGs, caching TileJSON, and updating layers.
 */
class MapController {
  constructor(mapId) {
    this.map = L.map(mapId, {
      zoomControl: false,
      fadeAnimation: false, // Disable Leaflet fade, we do it manually
      worldCopyJump: false
    }).setView(CONFIG.initialView.center, CONFIG.initialView.zoom);

    L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
      maxZoom: 20, attribution: '&copy; OpenStreetMap &copy; CARTO'
    }).addTo(this.map);

    this.cache = {}; // Stores TileJSON and Layer objects
    this.activeLayers = []; // Currently visible Leaflet layers
  }

  async getLayerData(filename) {
    if (this.cache[filename]) return this.cache[filename];
    
    try {
      const url = Utils.buildCogUrl(filename);
      const res = await fetch(url);
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const tileJson = await res.json();
      
      const tileUrl = tileJson.tiles[0];
      const layer = L.tileLayer(tileUrl, {
        minZoom: tileJson.minzoom || 0,
        maxZoom: 22,
        tileSize: 256,
        opacity: 0, // Start hidden
        zIndex: 10
      });

      this.cache[filename] = { layer, bounds: tileJson.bounds };
      return this.cache[filename];
    } catch (e) {
      console.error(`Failed to load ${filename}`, e);
      Utils.toast(`Error loading ${filename}`);
      return null;
    }
  }

  // Preload specific frame index
  async preloadFrame(index) {
    if (!CONFIG.frames[index]) return;
    const promises = CONFIG.frames[index].files.map(f => this.getLayerData(f));
    await Promise.all(promises);
  }

  // The core logic: Ensure target frame is visible, hide others
  async showFrame(index) {
    const frame = CONFIG.frames[index];
    document.getElementById('loader').classList.add('active');

    // 1. Load data for this frame if needed
    const layerDataList = await Promise.all(frame.files.map(f => this.getLayerData(f)));
    
    // 2. Add new layers to map (hidden initially via opacity:0 in definition)
    const newLayers = [];
    layerDataList.forEach(d => {
      if(d && d.layer) {
        if(!this.map.hasLayer(d.layer)) d.layer.addTo(this.map);
        newLayers.push(d.layer);
      }
    });

    // 3. Transition: Fade IN new, Fade OUT old
    // We use a small timeout to allow the browser to render the DOM element before CSS transition
    requestAnimationFrame(() => {
      newLayers.forEach(l => l.setOpacity(1));
      
      // Find layers to remove (all currently active layers that are NOT in the new set)
      const toRemove = this.activeLayers.filter(l => !newLayers.includes(l));
      toRemove.forEach(l => {
        l.setOpacity(0);
        // Remove from DOM after transition to save memory
        setTimeout(() => { if(this.map.hasLayer(l)) this.map.removeLayer(l); }, 600); 
      });

      this.activeLayers = newLayers;
      document.getElementById('loader').classList.remove('active');
    });

    // 4. Background load next frame for speed
    const nextIdx = (index + 1) % CONFIG.frames.length;
    this.preloadFrame(nextIdx);
  }
}

/**
 * TIMELINE CONTROLLER
 * Handles UI, User Input, and Animation Loop
 */
class TimelineApp {
  constructor(mapController) {
    this.mapCtrl = mapController;
    this.frames = CONFIG.frames;
    
    // Calculate Percentages
    const dates = this.frames.map(f => new Date(f.date).getTime());
    const min = Math.min(...dates);
    const max = Math.max(...dates);
    this.frames.forEach((f, i) => {
      const d = dates[i];
      f.pct = max === min ? 0 : ((d - min) / (max - min)) * 100;
    });

    this.currentIndex = 0;
    this.isPlaying = false;
    this.timer = null;

    this.ui = {
      playBtn: document.getElementById('playBtn'),
      progress: document.getElementById('progress'),
      handle: document.getElementById('handle'),
      track: document.getElementById('trackWrapper'),
      lblYear: document.getElementById('lblYear'),
      lblRange: document.getElementById('lblRange'),
      ticks: document.getElementById('ticksContainer')
    };

    this.initUI();
    this.update(0);
    
    // Global Keys
    window.addEventListener('keydown', (e) => {
      if(e.key === ' '){ this.togglePlay(); e.preventDefault(); }
      if(e.key === 'ArrowRight') this.step(1);
      if(e.key === 'ArrowLeft') this.step(-1);
    });
  }

  initUI() {
    // Generate Ticks
    this.frames.forEach((f, i) => {
      const tick = document.createElement('div');
      tick.className = 'tick';
      tick.style.left = `${f.pct}%`;
      this.ui.ticks.appendChild(tick);
    });

    // Play Button
    this.ui.playBtn.onclick = () => this.togglePlay();

    // Drag / Click Logic
    const handleInput = (clientX) => {
      const rect = this.ui.track.getBoundingClientRect();
      const x = Math.max(0, Math.min(clientX - rect.left, rect.width));
      const pct = (x / rect.width) * 100;
      
      // Find closest frame
      let closestIdx = 0;
      let minDiff = Infinity;
      this.frames.forEach((f, i) => {
        const diff = Math.abs(f.pct - pct);
        if(diff < minDiff) { minDiff = diff; closestIdx = i; }
      });
      
      if(closestIdx !== this.currentIndex) {
        this.update(closestIdx);
      }
    };

    let isDragging = false;
    const startDrag = (e) => { isDragging = true; this.stop(); handleInput(e.clientX || e.touches[0].clientX); };
    const moveDrag = (e) => { if(isDragging) handleInput(e.clientX || e.touches[0].clientX); };
    const endDrag = () => { isDragging = false; };

    this.ui.track.addEventListener('mousedown', startDrag);
    this.ui.track.addEventListener('touchstart', startDrag, {passive:false});
    window.addEventListener('mousemove', moveDrag);
    window.addEventListener('touchmove', moveDrag, {passive:false});
    window.addEventListener('mouseup', endDrag);
    window.addEventListener('touchend', endDrag);
  }

  update(index) {
    this.currentIndex = index;
    const f = this.frames[index];
    
    // Update UI
    this.ui.handle.style.left = `${f.pct}%`;
    this.ui.progress.style.width = `${f.pct}%`;
    this.ui.lblYear.textContent = f.id;
    this.ui.lblRange.textContent = `${this.frames[0].id} — ${this.frames[this.frames.length-1].id}`;

    // Update Map
    this.mapCtrl.showFrame(index);
  }

  step(dir) {
    this.stop();
    let next = this.currentIndex + dir;
    if(next >= this.frames.length) next = 0;
    if(next < 0) next = this.frames.length - 1;
    this.update(next);
  }

  togglePlay() {
    if(this.isPlaying) this.stop();
    else this.play();
  }

  play() {
    this.isPlaying = true;
    this.ui.playBtn.textContent = '❚❚';
    this.timer = setInterval(() => {
      const next = (this.currentIndex + 1) % this.frames.length;
      this.update(next);
    }, CONFIG.animationSpeed);
  }

  stop() {
    this.isPlaying = false;
    this.ui.playBtn.textContent = '▶';
    clearInterval(this.timer);
  }
}

// --- Bootstrap ---
document.addEventListener('DOMContentLoaded', () => {
  const mapCtrl = new MapController('map');
  const app = new TimelineApp(mapCtrl);
});

</script>
</body>
</html>
