<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Leaflet + tiles.rdnt.io (crisp)</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <style>
    html, body, #map { height: 100%; margin: 0; }
  </style>
</head>
<body>
<div id="map"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
(async () => {
  // 1) Your public COG URL
  const COG_URL = 'https://aeromap.io/201109S_geo_COG.tif'; // <-- replace if you want

  // 2) Map init + HTTPS basemap to avoid mixed content
  const map = L.map('map', { zoomControl: true });
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '&copy; OpenStreetMap contributors'
  }).addTo(map);

  // 3) Build common query params for tiles.rdnt.io
  //    - rgb=1,2,3 : pick bands (change if needed)
  //    - linearStretch=true : auto contrast stretch (optional but usually nicer)
  //    - resampling=lanczos : sharper downsampling when zoomed out
  const params = new URLSearchParams({
    url: COG_URL,
    rgb: '1,2,3',
    linearStretch: 'true',
    resampling: 'lanczos'
    // nodata: '0' // uncomment & set if your data needs it
  });

  // 4) Try TileJSON first to get bounds/min/max zoom from the server
  let tileTemplate, minzoom = 0, maxzoom = 22, bounds = null;
  try {
    const tj = await fetch('https://tiles.rdnt.io/tiles?' + params.toString()).then(r => r.json());
    tileTemplate = tj.tiles[0];           // e.g. https://tiles.rdnt.io/tiles/{z}/{x}/{y}?...
    minzoom = tj.minzoom ?? minzoom;
    maxzoom = tj.maxzoom ?? maxzoom;
    if (tj.bounds && tj.bounds.length === 4) bounds = tj.bounds; // [w,s,e,n]
  } catch (e) {
    // Fallback: construct the XYZ template directly if TileJSON fetch fails
    tileTemplate = 'https://tiles.rdnt.io/tiles/{z}/{x}/{y}?' + params.toString();
    console.warn('TileJSON fetch failed, using direct template:', e);
  }

  // 5) Retina / crispness setup
  //    - "@2x" path + detectRetina => high-DPI tiles on capable displays
  //    - tileSize: 512 + zoomOffset: -1 => pull higher-zoom tiles (crisper when zoomed out)
  //      (This increases per-tile detail; slightly more bandwidth.)
  const retinaTemplate = tileTemplate.replace('/tiles/', '/tiles/@2x/');
  const raster = L.tileLayer(retinaTemplate, {
    minZoom: minzoom,
    maxZoom: maxzoom,
    crossOrigin: true,
    detectRetina: true,
    tileSize: 512,
    zoomOffset: -1
  }).addTo(map);

  // 6) Fit to raster bounds if we got them; otherwise pick a sane world view
  if (bounds) {
    const [[s, w, n, e]] = [[bounds[1], bounds[0], bounds[3], bounds[2]]];
    map.fitBounds([[s, w], [n, e]], { padding: [16, 16] });
  } else {
    map.setView([0, 0], 2);
  }

  // Optional: log what we actually used
  console.log('tiles.rdnt.io template:', retinaTemplate);
})();
</script>
</body>
</html>