<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>DFW Sectionals — Timeline</title>
  
  <!-- Performance: Preconnect to external domains -->
  <link rel="preconnect" href="https://tiles.rdnt.io" crossorigin />
  <link rel="preconnect" href="https://aeromap.io" crossorigin />
  <link rel="preconnect" href="https://unpkg.com" crossorigin />
  <link rel="dns-prefetch" href="https://tiles.rdnt.io" />
  <link rel="dns-prefetch" href="https://aeromap.io" />
  
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    :root {
      --primary: #1e90ff;
      --bg-glass: rgba(20, 25, 30, 0.85); /* Slightly more transparent for mobile */
      --text-light: #fff;
      --timeline-h: 6px;
      --card-radius: 16px;
    }
    
    html, body { height: 100%; margin: 0; background: #111; font-family: system-ui, -apple-system, sans-serif; overflow: hidden; }
    #map { height: 100%; width: 100%; z-index: 1; background: #111; }

    /* Map Performance Tweaks */
    .leaflet-fade-anim .leaflet-tile,
    .leaflet-zoom-anim .leaflet-zoom-animated { will-change: transform; }
    
    /* Performance: GPU acceleration for animated elements */
    .timeline-progress, .handle, .tick { will-change: transform, opacity; }
    .controls-card { will-change: transform; } 

    /* UI Container */
    .ui-layer { 
      position: absolute; 
      bottom: 30px; 
      left: 50%; 
      transform: translateX(-50%); 
      width: min(1000px, 94vw); 
      z-index: 1000; 
      pointer-events: none;
    }

    /* Main Control Card */
    .controls-card { 
      background: var(--bg-glass); 
      backdrop-filter: blur(12px); 
      -webkit-backdrop-filter: blur(12px);
      padding: 16px 24px; 
      border-radius: var(--card-radius); 
      box-shadow: 0 8px 32px rgba(0,0,0,0.6); 
      border: 1px solid rgba(255,255,255,0.1); 
      
      display: flex; 
      align-items: center; 
      gap: 20px; 
      pointer-events: auto; 
    }

    /* Play Button */
    .btn-play { 
      width: 44px; height: 44px; 
      border-radius: 50%; 
      background: var(--primary); 
      border: none; color: white; 
      font-size: 18px; cursor: pointer; 
      display: grid; place-items: center; 
      transition: all 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94); 
      flex-shrink: 0; padding-left: 4px; 
      /* Larger touch target without changing visuals */
      box-shadow: 0 4px 12px rgba(30, 144, 255, 0.3);
    }
    .btn-play.paused { padding-left: 0; }
    .btn-play:active { transform: scale(0.92); }

    /* Timeline Track */
    .timeline-track-wrapper { 
      flex: 1; 
      position: relative; 
      height: 40px; /* Taller hit area for touch */
      display: flex; 
      align-items: center; 
      cursor: pointer; 
      touch-action: none; /* Prevents scrolling while dragging */
    }
    .timeline-track { width: 100%; height: var(--timeline-h); background: rgba(255,255,255,0.2); border-radius: 4px; position: relative; }
    .timeline-progress { position: absolute; height: 100%; background: var(--primary); border-radius: 4px; width: 0%; pointer-events: none; }

    .tick { position: absolute; width: 2px; height: 12px; background: rgba(255,255,255,0.4); top: 50%; transform: translate(-50%, -50%); pointer-events: none; transition: height 0.2s, background 0.2s; }
    .tick.active { background: #fff; height: 16px; opacity: 1; box-shadow: 0 0 8px rgba(255,255,255,0.5); }

    /* Slider Handle */
    .handle { 
      position: absolute; 
      width: 20px; height: 20px; 
      background: #fff; border-radius: 50%; 
      top: 50%; transform: translate(-50%, -50%); 
      box-shadow: 0 0 0 4px rgba(30,144,255,0.4); 
      cursor: grab; transition: transform 0.1s; 
      z-index: 2;
    }
    /* Invisible larger hit area for the handle */
    .handle::after {
        content: ''; position: absolute;
        top: -15px; left: -15px; right: -15px; bottom: -15px;
    }
    .handle:active { cursor: grabbing; transform: translate(-50%, -50%) scale(1.15); }

    /* Info Panel */
    .info-panel { 
      display: flex; flex-direction: column; align-items: flex-end; 
      min-width: 100px; color: var(--text-light); 
      text-align: right;
    }
    .label-sub { font-size: 11px; opacity: 0.6; margin-top: 4px; font-weight: 500; text-transform: uppercase; letter-spacing: 0.5px;}

    /* Loader */
    .loader { width: 18px; height: 18px; border: 2px solid rgba(255,255,255,0.1); border-top-color: var(--primary); border-radius: 50%; animation: spin 0.8s linear infinite; opacity: 0; transition: opacity 0.2s; margin-right: 10px;}
    .loader.active { opacity: 1; }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* Toast */
    .toast { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background: #e74c3c; color: white; padding: 10px 20px; border-radius: 20px; font-weight: 600; font-size: 13px; z-index: 2000; opacity: 0; transition: opacity 0.3s; pointer-events: none; box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
    .toast.visible { opacity: 1; }

    /* Dropdown styling */
    .time-select {
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
      background: rgba(255,255,255,0.08);
      color: var(--text-light);
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 10px;
      padding: 8px 36px 8px 12px;
      font-size: 16px;
      font-weight: 700;
      letter-spacing: -0.3px;
      line-height: 1;
      outline: none;
      cursor: pointer;
      position: relative;
    }
    /* simple chevron */
    .time-select {
      background-image:
        linear-gradient(45deg, transparent 50%, rgba(255,255,255,0.7) 50%),
        linear-gradient(135deg, rgba(255,255,255,0.7) 50%, transparent 50%);
      background-position:
        calc(100% - 18px) calc(50% - 3px),
        calc(100% - 12px) calc(50% - 3px);
      background-size: 6px 6px, 6px 6px;
      background-repeat: no-repeat;
    }

    /* --- MOBILE OPTIMIZATIONS --- */
    @media (max-width: 640px) {
      .ui-layer { bottom: 20px; width: 92vw; }
      
      .controls-card {
        flex-wrap: wrap; /* Allow items to wrap to next line */
        padding: 16px;   /* Reduce padding slightly */
        gap: 12px;       /* Tighter gap */
        justify-content: space-between;
      }

      /* Row 1: Play Button & Date Info */
      .btn-play { order: 1; }
      
      .info-panel { 
        order: 2; 
        align-items: center; /* Center align text for balance */
        flex-direction: row; /* Put label/sub on same line or stack differently if preferred */
        gap: 10px;
      }
      .label-sub { margin-top: 0; display: none; /* Hide 'Timeline' text on mobile to save space */ }

      /* Row 2: The Timeline (Full Width) */
      .timeline-track-wrapper {
        order: 3;
        flex-basis: 100%; /* Force full width */
        width: 100%;
        margin-top: 10px; /* Add spacing from top row */
        height: 44px; /* Even bigger touch target */
      }
      
      /* Hide loader on mobile to save space, or move it */
      .loader { position: absolute; top: 16px; left: 70px; } 

      .time-select { font-size: 15px; padding: 8px 34px 8px 10px; }
      
      /* Hide speed control on small mobile */
      .speed-btn { display: none; }
    }
    
    /* Speed control button */
    .speed-btn {
      background: rgba(255,255,255,0.08);
      color: var(--text-light);
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 8px;
      padding: 6px 10px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s;
      min-width: 42px;
      text-align: center;
    }
    .speed-btn:hover { background: rgba(255,255,255,0.15); }
    .speed-btn:active { transform: scale(0.95); }
    
    /* Fullscreen button */
    .fullscreen-btn {
      position: absolute;
      top: 20px;
      right: 20px;
      z-index: 1000;
      width: 40px;
      height: 40px;
      background: var(--bg-glass);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 10px;
      color: var(--text-light);
      font-size: 18px;
      cursor: pointer;
      display: grid;
      place-items: center;
      transition: background 0.2s, transform 0.2s;
    }
    .fullscreen-btn:hover { background: rgba(255,255,255,0.15); }
    .fullscreen-btn:active { transform: scale(0.92); }
    
    /* Keyboard shortcuts hint */
    .kbd-hint {
      position: absolute;
      bottom: 120px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--bg-glass);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      padding: 8px 16px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.1);
      font-size: 12px;
      color: var(--text-light);
      opacity: 0;
      transition: opacity 0.3s;
      pointer-events: none;
      z-index: 999;
    }
    .kbd-hint.visible { opacity: 0.9; }
    .kbd-hint kbd {
      background: rgba(255,255,255,0.15);
      padding: 2px 6px;
      border-radius: 4px;
      margin: 0 4px;
      font-family: inherit;
    }
  </style>

  <script async src="https://plausible.io/js/pa-oIee4DcCO6MlCK-80VGrZ.js"></script>
  <script>
    window.plausible=window.plausible||function(){(plausible.q=plausible.q||[]).push(arguments)},plausible.init=plausible.init||function(i){plausible.o=i||{}};
    plausible.init()
  </script>
</head>
<body>

<div id="map"></div>
<div class="toast" id="toast"></div>
<button type="button" class="fullscreen-btn" id="fullscreenBtn" title="Toggle Fullscreen (F)">⛶</button>
<div class="kbd-hint" id="kbdHint"><kbd>Space</kbd> Play/Pause <kbd>←</kbd><kbd>→</kbd> Navigate <kbd>F</kbd> Fullscreen</div>

<div class="ui-layer">
  <div class="controls-card">
    <button type="button" class="btn-play" id="playBtn" title="Play/Pause (Space)">▶</button>
    <div class="loader" id="loader"></div>

    <div class="timeline-track-wrapper" id="trackWrapper">
      <div class="timeline-track">
        <div class="timeline-progress" id="progress"></div>
        <div id="ticksContainer"></div>
        <div class="handle" id="handle"></div>
      </div>
    </div>

    <div class="info-panel">
      <button type="button" class="speed-btn" id="speedBtn" title="Playback Speed">1x</button>
      <select id="timeSelect" class="time-select" aria-label="Select timeframe"></select>
      <div class="label-sub" id="lblRange">Timeline</div>
    </div>
  </div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
/** CONFIGURATION **/
const CONFIG = {
  rdntEndpoint: 'https://tiles.rdnt.io/tiles',
  rdntQuery: '&rgb=1,2,3',
  // Updated base URL to include the "dfw/" folder
  baseUrl: 'https://aeromap.io/dfw/',
  // Updated frames list based on the uploaded image content
  frames: [
    { id: '1933 Feb', date: '1933-02-01', files: ['193302_geo_COG.tif'] },
    { id: '1933 Jul', date: '1933-07-01', files: ['193307_geo_COG.tif'] },
    { id: '1933 Sep', date: '1933-09-01', files: ['193309_geo_COG.tif'] },
    { id: '1934 Aug', date: '1934-08-01', files: ['193408_geo_COG.tif'] },
    { id: '1940 Sep', date: '1940-09-01', files: ['194009_DFW_COG.tif'] },
    { id: '1950 Feb', date: '1950-02-01', files: ['195002_DFW_COG.tif'] },
    { id: '2011 Sep', date: '2011-09-01', files: ['201109N_geo_COG.tif', '201109S_geo_COG.tif'] },
    { id: '2012 Sep', date: '2012-09-01', files: ['201209N_geo_COG.tif', '201209S_geo_COG.tif'] },
    { id: '2013 Sep', date: '2013-09-01', files: ['201309N_geo_COG.tif', '201309S_geo_COG.tif'] },
    { id: '2014 Mar', date: '2014-03-01', files: ['201403_geo_COG.tif'] },
    { id: '2015 Mar', date: '2015-03-01', files: ['201503_geo_COG.tif'] },
    { id: '2016 Mar', date: '2016-03-01', files: ['201603_geo_COG.tif'] },
    { id: '2016 Sep', date: '2016-09-01', files: ['201609_geo_COG.tif'] }
  ],
  animationSpeed: 1000,
  speedOptions: [0.5, 1, 2, 3], // Playback speed multipliers
  initialView: { center: [32.7767, -96.7970], zoom: 10 },
  preloadCount: 2 // Number of frames to preload ahead
};

/** UTILITIES **/
const Utils = {
  buildCogUrl: (filename) => {
    // baseUrl now includes 'dfw/', so we just append the filename
    const encoded = encodeURIComponent(CONFIG.baseUrl + filename);
    return `${CONFIG.rdntEndpoint}?url=${encoded}${CONFIG.rdntQuery}`;
  },
  toast: (msg, duration=3000) => {
    const el = document.getElementById('toast');
    el.textContent = msg;
    el.classList.add('visible');
    setTimeout(() => el.classList.remove('visible'), duration);
  }
};

/** MAP CONTROLLER **/
class MapController {
  constructor(mapId) {
    this.map = L.map(mapId, {
      zoomControl: false,
      fadeAnimation: true,
      zoomAnimation: true,
      attributionControl: false 
    }).setView(CONFIG.initialView.center, CONFIG.initialView.zoom);

    L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
      maxZoom: 20, opacity: 1, zIndex: 1
    }).addTo(this.map);
    
    // Add zoom control top-right for better mobile UX
    L.control.zoom({ position: 'topright' }).addTo(this.map);

    this.cache = {};
    this.activeLayers = [];
  }

  async getLayerData(filename) {
    if (this.cache[filename]) return this.cache[filename];
    try {
      const url = Utils.buildCogUrl(filename);
      const res = await fetch(url);
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const tileJson = await res.json();

      const tileUrl = tileJson.tiles[0];
      const layer = L.tileLayer(tileUrl, {
        minZoom: tileJson.minzoom || 0,
        maxZoom: 22,
        tileSize: 256,
        opacity: 0,
        zIndex: 10,
        keepBuffer: 2 // Reduced buffer for mobile memory optimization
      });

      this.cache[filename] = { layer, bounds: tileJson.bounds };
      return this.cache[filename];
    } catch (e) {
      console.error(`Failed to load ${filename}`, e);
      Utils.toast(`Err: ${filename}`);
      return null;
    }
  }

  async preloadFrame(index) {
    if (!CONFIG.frames[index]) return;
    // Debounce preload slightly to prioritize current render
    setTimeout(() => {
        CONFIG.frames[index].files.forEach(f => this.getLayerData(f));
    }, 200);
  }

  // Preload multiple frames ahead for smoother playback
  preloadAhead(currentIndex, count = CONFIG.preloadCount) {
    for (let i = 1; i <= count; i++) {
      const nextIdx = (currentIndex + i) % CONFIG.frames.length;
      this.preloadFrame(nextIdx);
    }
  }

  waitForLayer(layer) {
    return new Promise(resolve => {
      // If already loaded, resolve immediately
      if (layer._tiles && Object.keys(layer._tiles).length > 0) return resolve();
      
      const onload = () => { layer.off('load', onload); resolve(); };
      layer.on('load', onload);
      setTimeout(() => { layer.off('load', onload); resolve(); }, 2000); // Faster timeout
    });
  }

  async showFrame(index) {
    const frame = CONFIG.frames[index];
    const loader = document.getElementById('loader');

    const spinnerTimeout = setTimeout(() => loader.classList.add('active'), 100);

    const layerDataList = await Promise.all(frame.files.map(f => this.getLayerData(f)));

    const newLayers = [];
    layerDataList.forEach(d => {
      if (d && d.layer) {
        if (!this.map.hasLayer(d.layer)) {
          d.layer.setOpacity(0);
          d.layer.addTo(this.map);
        }
        newLayers.push(d.layer);
      }
    });

    // On mobile, we might skip waiting for full load to keep UI snappy
    const isMobile = window.innerWidth < 640;
    if (!isMobile) {
        await Promise.all(newLayers.map(l => this.waitForLayer(l)));
    }

    requestAnimationFrame(() => {
      newLayers.forEach(l => l.setOpacity(1));
      this.activeLayers.forEach(l => { if (!newLayers.includes(l)) this.map.removeLayer(l); });
      this.activeLayers = newLayers;

      clearTimeout(spinnerTimeout);
      loader.classList.remove('active');
    });

    // Preload multiple frames ahead for smoother playback
    this.preloadAhead(index);
  }
}

/** TIMELINE CONTROLLER **/
class TimelineApp {
  constructor(mapController) {
    this.mapCtrl = mapController;
    this.frames = CONFIG.frames;

    const dates = this.frames.map(f => new Date(f.date).getTime());
    const min = Math.min(...dates);
    const max = Math.max(...dates);
    this.frames.forEach((f, i) => { const d = dates[i]; f.pct = max === min ? 0 : ((d - min) / (max - min)) * 100; });

    this.currentIndex = 0;
    this.isPlaying = false;
    this.timer = null;
    this.speedIndex = 1; // Default to 1x speed (index 1 in speedOptions)
    this.kbdHintShown = false;

    this.ui = {
      playBtn: document.getElementById('playBtn'),
      progress: document.getElementById('progress'),
      handle: document.getElementById('handle'),
      track: document.getElementById('trackWrapper'),
      timeSelect: document.getElementById('timeSelect'),
      lblRange: document.getElementById('lblRange'),
      ticks: document.getElementById('ticksContainer'),
      speedBtn: document.getElementById('speedBtn'),
      fullscreenBtn: document.getElementById('fullscreenBtn'),
      kbdHint: document.getElementById('kbdHint')
    };

    this.initUI();
    this.update(0);
    this.showKbdHint(); // Show keyboard hint on first load

    window.addEventListener('keydown', (e) => {
      if (e.key === ' ') { this.togglePlay(); e.preventDefault(); }
      if (e.key === 'ArrowRight') this.step(1);
      if (e.key === 'ArrowLeft') this.step(-1);
      if (e.key === 'f' || e.key === 'F') this.toggleFullscreen();
      if (e.key === '+' || e.key === '=') this.cycleSpeed();
    });
  }

  showKbdHint() {
    if (this.kbdHintShown) return;
    this.kbdHintShown = true;
    setTimeout(() => {
      this.ui.kbdHint.classList.add('visible');
      setTimeout(() => this.ui.kbdHint.classList.remove('visible'), 4000);
    }, 1500);
  }

  toggleFullscreen() {
    if (!document.fullscreenElement) {
      document.documentElement.requestFullscreen().catch(() => {});
    } else {
      document.exitFullscreen().catch(() => {});
    }
  }

  cycleSpeed() {
    this.speedIndex = (this.speedIndex + 1) % CONFIG.speedOptions.length;
    const speed = CONFIG.speedOptions[this.speedIndex];
    this.ui.speedBtn.textContent = speed + 'x';
    
    // Restart timer if playing to apply new speed
    if (this.isPlaying) {
      this.stop();
      this.play();
    }
  }

  getAnimationInterval() {
    const speed = CONFIG.speedOptions[this.speedIndex];
    return CONFIG.animationSpeed / speed;
  }

  initUI() {
    this.ui.lblRange.textContent = `${this.frames[0].id} — ${this.frames[this.frames.length-1].id}`;

    // Speed button
    this.ui.speedBtn.onclick = () => this.cycleSpeed();

    // Fullscreen button
    this.ui.fullscreenBtn.onclick = () => this.toggleFullscreen();

    // populate dropdown
    this.ui.timeSelect.innerHTML = '';
    this.frames.forEach((f, i) => {
      const opt = document.createElement('option');
      opt.value = String(i);
      opt.textContent = f.id; // e.g., "1933 Feb"
      this.ui.timeSelect.appendChild(opt);
    });
    this.ui.timeSelect.addEventListener('change', () => {
      const idx = parseInt(this.ui.timeSelect.value, 10);
      if (!Number.isNaN(idx) && idx >= 0 && idx < this.frames.length) {
        this.stop(); // pause if it was playing
        this.update(idx);
      }
    });

    // ticks
    this.frames.forEach((f) => {
      const tick = document.createElement('div');
      tick.className = 'tick';
      tick.style.left = `${f.pct}%`;
      this.ui.ticks.appendChild(tick);
    });

    // play
    this.ui.playBtn.onclick = () => this.togglePlay();

    // drag on the track/handle
    const handleInput = (clientX) => {
      const rect = this.ui.track.getBoundingClientRect();
      const x = Math.max(0, Math.min(clientX - rect.left, rect.width));
      const pct = (x / rect.width) * 100;

      let closestIdx = 0, minDiff = Infinity;
      this.frames.forEach((f, i) => {
        const diff = Math.abs(f.pct - pct);
        if (diff < minDiff) { minDiff = diff; closestIdx = i; }
      });

      if (closestIdx !== this.currentIndex) this.update(closestIdx);
    };

    let isDragging = false;
    const startDrag = (e) => { 
        isDragging = true; 
        this.stop(); 
        handleInput((e.touches?.[0]?.clientX) ?? e.clientX); 
    };
    const moveDrag  = (e) => { if (isDragging) handleInput((e.touches?.[0]?.clientX) ?? e.clientX); };
    const endDrag   = () => { isDragging = false; };

    // Added passive: false to allow touch manipulation
    this.ui.track.addEventListener('mousedown', startDrag);
    this.ui.track.addEventListener('touchstart', startDrag, {passive:false});
    window.addEventListener('mousemove', moveDrag);
    window.addEventListener('touchmove', moveDrag, {passive:false});
    window.addEventListener('mouseup', endDrag);
    window.addEventListener('touchend', endDrag);
  }

  update(index) {
    this.currentIndex = index;
    const f = this.frames[index];

    // sync dropdown
    if (this.ui.timeSelect && this.ui.timeSelect.value !== String(index)) {
      this.ui.timeSelect.value = String(index);
    }

    // move handle/progress & highlight tick
    this.ui.handle.style.left = `${f.pct}%`;
    this.ui.progress.style.width = `${f.pct}%`;

    Array.from(this.ui.ticks.children).forEach((tick, i) => {
      if (i === index) tick.classList.add('active'); else tick.classList.remove('active');
    });

    this.mapCtrl.showFrame(index);
  }

  step(dir) {
    this.stop();
    let next = this.currentIndex + dir;
    if (next >= this.frames.length) next = 0;
    if (next < 0) next = this.frames.length - 1;
    this.update(next);
  }

  togglePlay() {
    if (this.isPlaying) this.stop(); else this.play();
  }

  play() {
    this.isPlaying = true;
    this.ui.playBtn.textContent = '❚❚';
    this.ui.playBtn.classList.add('paused');
    this.timer = setInterval(() => this.update((this.currentIndex + 1) % this.frames.length), this.getAnimationInterval());
  }

  stop() {
    this.isPlaying = false;
    this.ui.playBtn.textContent = '▶';
    this.ui.playBtn.classList.remove('paused');
    clearInterval(this.timer);
  }
}

document.addEventListener('DOMContentLoaded', () => {
  const mapCtrl = new MapController('map');
  new TimelineApp(mapCtrl);
});
</script>
</body>
</html>
